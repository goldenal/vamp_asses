# Reserved Cart Backend

A minimal, production-structured NestJS backend for a Reserved Cart system.

## üèó Architectural Overview

This project implements a **Reserved Cart** system where users can reserve limited stock items for a specific duration. The backend is the **single source of truth** for time and inventory state.

### Core Modules

- **TimeModule**: Centralized time generation. Prevents client-side drift or timezone issues.
- **CartModule**: Manages in-memory shopping carts. Enforces expiry policies strictly on every read/write operation.
- **ProductsModule**: Hardcoded product inventory (simulating a DB).
- **HealthModule**: Uptime monitoring for platform-as-a-service (PaaS) deployments like Render.

## ‚è± Server-Side Time Authority

In this system, **the client never calculates expiry**.

- All timestamps (`reservedUntil`) are generated by the server.
- The server exposes its current time (`serverTime`) in responses to allow clients to synchronize their countdown timers (e.g., `remaining = reservedUntil - serverTime`).

## üßπ Expiry Enforcement (No Cron Jobs)

To keep the architecture simple and stateless, we avoid background workers or cron jobs.
Instead, expiry is **lazily enforced**:

1.  **On Read (`GET /cart`)**: Before returning the cart, we filter out any items where `reservedUntil < now`.
2.  **On Write (`POST /cart/reserve`)**: Before processing a new reservation, we clean the user's cart of expired items.

This ensures that the user **never sees** an expired item, and expired items do not consume logical "slots" during new operations, effectively achieving the same result as a background cleaner without the infrastructure overhead.

## üíæ In-Memory Storage

We use a `Map<string, CartItem[]>` for storage.

- **Why?** It's the fastest way to prototype and achieves microsecond latency.
- **Constraint**: Data is lost on server restart.

## üöÄ Scaling to Production

To move from this prototype to a real high-traffic production system:

1.  **Storage**: Replace `Map` with **Redis**.
2.  **Inventory**: Move `ProductsStore` to a relational database (Postgres).
3.  **Concurrency**: Implement distributed locking.

## ‚òÅÔ∏è Deployment (Render)

### Health Check

Render requires a health check endpoint to know if the service is alive.

- **Endpoint**: `GET /health`
- **Response**: `200 OK` with `{ status: 'ok', time: '...' }`
- **Usage**: Configure Render's "Health Check Path" to `/health`.

## üõ† Usage

### Install

```bash
npm install
```

### Run

```bash
npm run start
```

### Verify

Run the included verification script:

```bash
npx ts-node verify_backend.ts
```

## üìö API Reference

### 1. Health Check

Check API uptime.

**Request:** `GET /health`

**Response:**

```json
{
  "status": "ok",
  "time": "2025-12-18T12:00:00Z"
}
```

### 2. List Products

Fetch all available products and their stock.

**Request:** `GET /products`

**Response:**

```json
[
  { "id": "sku_1", "name": "Limited Sneakers", "stock": 5 },
  { "id": "sku_2", "name": "Rare Hoodie", "stock": 3 },
  { "id": "sku_3", "name": "Vintage Cap", "stock": 10 },
  ...
]
```

### 3. Reserve Item

Reserve a product for a user for 5 minutes.

**Request:** `POST /cart/reserve`

```json
{
  "userId": "user_123",
  "productId": "sku_1"
}
```

**Response:**

```json
{
  "productId": "sku_1",
  "reservedUntil": "2025-12-18T12:05:00Z"
}
```

### 4. Get Cart

Retrieve a user's active reservations. Includes server time for sync.

**Request:** `GET /cart?userId=user_123`

**Response:**

```json
{
  "items": [
    {
      "productId": "sku_1",
      "reservedUntil": "2025-12-18T12:05:00Z"
    }
  ],
  "serverTime": "2025-12-18T12:00:30Z"
}
```
